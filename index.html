<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>AstroPose v3 - Physics Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; color: #fff; }
        
        #input_video {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            object-fit: cover; transform: scaleX(-1); z-index: 0;
            opacity: 0.25; filter: contrast(1.2) grayscale(0.6);
        }
        #output_canvas { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }

        /* UI Elements */
        .logo {
            position: absolute; top: 20px; left: 20px; font-size: 22px; font-weight: 800; letter-spacing: 3px;
            background: linear-gradient(90deg, #00f2fe, #4facfe); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        
        .controls-box {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; background: rgba(0,0,0,0.6); padding: 10px 20px;
            border-radius: 30px; border: 1px solid rgba(255,255,255,0.1);
        }
        .control-item { font-size: 14px; color: #ccc; display: flex; align-items: center; gap: 8px; }
        .icon-key { font-size: 18px; color: #00f2fe; }

        /* Info Panel */
        #info-panel {
            position: absolute; right: 30px; top: 50%; transform: translateY(-50%) translateX(50px);
            width: 260px; background: rgba(10, 20, 40, 0.9); border-left: 3px solid #00f2fe;
            padding: 20px; opacity: 0; transition: all 0.5s cubic-bezier(0.17, 0.84, 0.44, 1);
            backdrop-filter: blur(10px); border-radius: 0 15px 15px 0;
        }
        #info-panel.active { opacity: 1; transform: translateY(-50%) translateX(0); }
        .info-title { font-size: 18px; font-weight: bold; color: #00f2fe; margin-bottom: 5px; text-transform: uppercase; }
        .info-desc { font-size: 13px; line-height: 1.5; color: #ddd; }

        /* Loading Screen */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99; display: flex; flex-direction: column;
            align-items: center; justify-content: center; transition: opacity 0.5s;
        }
        .loader-spinner {
            width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #00f2fe;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Debug/Status */
        #debug-status { position: absolute; top: 20px; right: 20px; text-align: right; font-family: monospace; font-size: 12px; color: #00f2fe; }
    </style>
</head>
<body>

    <div id="loading">
        <div class="loader-spinner"></div>
        <div style="color: #00f2fe; letter-spacing: 2px;">INICIALIZANDO SISTEMA</div>
        <div style="color: #666; font-size: 12px; margin-top: 10px;">Permita o uso da câmera</div>
    </div>

    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <div id="ui-layer">
        <div class="logo">ASTROPOSE V3</div>
        <div id="debug-status">SISTEMA: AGUARDANDO</div>
        
        <div id="info-panel">
            <div class="info-title" id="geo-title">...</div>
            <div class="info-desc" id="geo-desc">...</div>
        </div>

        <div class="controls-box">
            <div class="control-item"><span class="icon-key">✊</span> ARRASTAR</div>
            <div class="control-item"><span class="icon-key">↔️</span> ZOOM</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- CONFIGURAÇÃO GERAL ---
        const videoElement = document.getElementById('input_video');
        const loadingScreen = document.getElementById('loading');
        const statusText = document.getElementById('debug-status');
        const infoPanel = document.getElementById('info-panel');
        const geoTitle = document.getElementById('geo-title');
        const geoDesc = document.getElementById('geo-desc');

        // --- THREE.JS (CENA) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 9;

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('output_canvas'), alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;

        // --- GERENCIADOR DE LOADING (CORREÇÃO DO BUG) ---
        const loadManager = new THREE.LoadingManager();
        // Se carregar tudo: some.
        loadManager.onLoad = () => { 
            console.log("Texturas carregadas.");
            // Não escondemos aqui, preferimos esconder quando a câmera iniciar para evitar tela branca
        };
        // Se der erro: loga mas continua.
        loadManager.onError = (url) => { console.warn('Erro ao carregar textura:', url); };

        // --- CRIAÇÃO DO GLOBO ---
        const earthGroup = new THREE.Group();
        earthGroup.position.x = -2.5; 
        scene.add(earthGroup);

        const texLoader = new THREE.TextureLoader(loadManager);
        
        // Materiais
        const earthGeo = new THREE.SphereGeometry(1.8, 64, 64);
        const earthMat = new THREE.MeshPhongMaterial({
            map: texLoader.load('https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg'),
            bumpMap: texLoader.load('https://unpkg.com/three-globe/example/img/earth-topology.png'),
            bumpScale: 0.08, specular: new THREE.Color(0x222222), shininess: 10
        });
        const earth = new THREE.Mesh(earthGeo, earthMat);
        earthGroup.add(earth);

        // Nuvens
        const cloudMat = new THREE.MeshPhongMaterial({
            map: texLoader.load('https://unpkg.com/three-globe/example/img/earth-clouds.png'),
            transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
        });
        const clouds = new THREE.Mesh(new THREE.SphereGeometry(1.83, 64, 64), cloudMat);
        earthGroup.add(clouds);

        // Luz Atmosférica
        const atmoMat = new THREE.MeshBasicMaterial({ color: 0x4facfe, transparent: true, opacity: 0.1, side: THREE.BackSide, blending: THREE.AdditiveBlending });
        earthGroup.add(new THREE.Mesh(new THREE.SphereGeometry(2.0, 64, 64), atmoMat));

        // Iluminação
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(5, 3, 5);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x111122)); 
        const rimLight = new THREE.SpotLight(0x00f2fe, 2);
        rimLight.position.set(-5, 5, 0);
        scene.add(rimLight);

        // --- SISTEMA DE FÍSICA E CONTROLE ---
        
        // Variáveis de estado
        let isFist = false;
        let lastHandPos = { x: 0, y: 0 };
        
        // Física de Rotação (Velocidade atual)
        let velocityX = 0; // Rotação no eixo X (Cima/Baixo)
        let velocityY = 0.002; // Rotação no eixo Y (Esquerda/Direita) - começa girando devagar
        
        // Variáveis de Zoom
        let targetScale = 1;
        
        // Constantes de Sensibilidade
        const DRAG_SENSITIVITY = 0.004; // Quão rápido gira ao arrastar
        const FRICTION = 0.95; // Quanto desliza depois de soltar (0.99 = gelo, 0.8 = areia)
        const ZOOM_SPEED = 0.08;

        // --- LOOP PRINCIPAL DE ANIMAÇÃO (THREE.JS) ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Aplica Velocidade à Rotação
            earthGroup.rotation.y += velocityY;
            earthGroup.rotation.x += velocityX;

            // 2. Aplica Atrito (Friction) - Reduz velocidade gradualmente se não estiver segurando
            if (!isFist) {
                velocityY *= FRICTION;
                velocityX *= FRICTION;
                
                // Velocidade mínima para rotação automática bonita
                if (Math.abs(velocityY) < 0.0005) velocityY = 0.0005; 
            }

            // 3. Zoom Suave
            const currentScale = earthGroup.scale.x;
            const smoothScale = THREE.MathUtils.lerp(currentScale, targetScale, ZOOM_SPEED);
            earthGroup.scale.set(smoothScale, smoothScale, smoothScale);

            // 4. Nuvens
            clouds.rotation.y += 0.0002;

            // 5. Lógica do Painel
            if (earthGroup.scale.x > 2.5) {
                infoPanel.classList.add('active');
                updateRegionInfo(earthGroup.rotation.y);
            } else {
                infoPanel.classList.remove('active');
            }

            renderer.render(scene, camera);
        }

        // --- DADOS GEOGRÁFICOS ---
        function updateRegionInfo(rotY) {
            let deg = (rotY % (Math.PI * 2)); 
            if(deg < 0) deg += Math.PI * 2;
            deg = THREE.MathUtils.radToDeg(deg);
            
            let t = "", d = "";
            // Mapeamento aproximado
            if (deg > 50 && deg < 110) { t = "Oceano Atlântico"; d = "Separa as Américas da Europa e da África."; }
            else if (deg >= 110 && deg < 170) { t = "Américas"; d = "Inclui a cordilheira dos Andes e a Amazônia."; }
            else if (deg >= 170 && deg < 290) { t = "Oceano Pacífico"; d = "Cobre um terço da superfície da Terra."; }
            else if (deg >= 290 && deg < 350) { t = "Ásia & Oceania"; d = "A região mais populosa do planeta."; }
            else { t = "Europa & África"; d = "O berço da civilização humana."; }
            
            geoTitle.innerText = t; geoDesc.innerText = d;
        }

        // --- MEDIAPIPE (VISÃO COMPUTACIONAL) ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        
        hands.onResults((results) => {
            // **CORREÇÃO DO LOADING**: Assim que detectar a primeira mão ou frame válido, remove o loading
            loadingScreen.style.opacity = '0';
            setTimeout(() => { loadingScreen.style.display = 'none'; }, 500);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusText.innerText = "STATUS: CONECTADO";
                statusText.style.color = "#00f2fe";

                const lm = results.multiHandLandmarks[0];
                
                // Posição atual da mão (Pixel Coordinate -> Normalized)
                // Usamos pixel real para calcular delta melhor
                const handX = lm[9].x * window.innerWidth; // Usando base do dedo médio (mais estável)
                const handY = lm[9].y * window.innerHeight;

                // Detecção de Punho (Pontas dos dedos perto do pulso)
                const wrist = lm[0];
                const tip = lm[12]; // Dedo médio
                const distFist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const currentlyFist = distFist < 0.3; // Threshold de punho

                if (currentlyFist) {
                    // --- MODO ARRASTAR (DRAG) ---
                    if (!isFist) {
                        // Acabou de fechar a mão: Reseta o "último ponto" para não dar pulo
                        isFist = true;
                        lastHandPos = { x: handX, y: handY };
                    } else {
                        // Já estava fechada: Calcula o DELTA (Movimento)
                        const deltaX = handX - lastHandPos.x;
                        const deltaY = handY - lastHandPos.y;

                        // Aplica o movimento à VELOCIDADE (Impulso)
                        // Invertemos X pois o vídeo é espelhado
                        velocityY = deltaX * DRAG_SENSITIVITY * -1; 
                        velocityX = deltaY * DRAG_SENSITIVITY * -1;

                        lastHandPos = { x: handX, y: handY };
                    }
                } else {
                    isFist = false;
                    // --- MODO ZOOM ---
                    const distPinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    // Fórmula de zoom agressiva
                    let z = 0.6 + (distPinch * 7);
                    targetScale = Math.max(0.7, Math.min(z, 5.0));
                }

            } else {
                statusText.innerText = "STATUS: PROCURANDO MÃO";
                statusText.style.color = "orange";
                isFist = false;
            }
        });

        // Inicializar Câmera
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraUtils.start();
        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>